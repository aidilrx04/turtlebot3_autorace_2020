#!/usr/bin/env python3

# Author: Muhamad Aidil
 
import json
import math
from geometry_msgs.msg import Twist
import rospy
import os
from enum import Enum
from std_msgs.msg import UInt8, Float64
from sensor_msgs.msg import LaserScan, Image
from turtlebot3_autorace_msgs.msg import MovingParam
import cv2
from cv_bridge import CvBridge
import time

class DetectParking():
    def __init__(self):
        self.cvBridge = CvBridge()  
        
        # subs
        self.sub_scan_obstracle = rospy.Subscriber('/detect/scan', LaserScan, self.cbScanObstacle, queue_size=1)
        self.sub_parking_order = rospy.Subscriber('/detect/parking_order', UInt8, self.cbParkingOrder, queue_size=1)
        self.sub_image = rospy.Subscriber('/detect/image_input', Image, self.cbGetImage, queue_size=1)
        self.sub_parking_trigger = rospy.Subscriber('/detect/trigger_parking', UInt8, self.cbTriggerParking, queue_size=1)

        # pub states
        self.pub_parking_return = rospy.Publisher('/detect/parking_stamped', UInt8, queue_size=1)
        self.pub_max_vel = rospy.Publisher('/control/max_vel', Float64, queue_size=1)
        self.pub_parking_start = rospy.Publisher('/control/parking_start', UInt8, queue_size=1)


        self.StepOfParking = Enum('StepOfParking', 'searching_parking_point_line searching_nonreserved_parking_area parking')
        self.current_parking_step = self.StepOfParking.searching_parking_point_line.value

        self.is_obstacle_detected = False
        self.is_parking_allowed = True

        self.cv_image = None

        self.is_triggered = False
        self.is_finish_detect = False
        self.is_control_parking_triggered = False

        while not rospy.is_shutdown():
            if self.is_triggered and not self.is_finish_detect:
                self.fnDetectParkingControl()

    def cbGetImage(self, image_msg) -> None:
        if image_msg is not None:
            # cvBridge = CvBridge()
            self.cv_image = self.cvBridge.imgmsg_to_cv2(image_msg, 'bgr8')

    def cbTriggerParking(self, _):
        rospy.loginfo_once("Detect parking triggered!")
        self.is_triggered = True

    def fnDetectParkingControl(self):
        rospy.loginfo_throttle(10, "Kontoling the detect")
        
        if self.current_parking_step == self.StepOfParking.searching_parking_point_line.value:
            rospy.loginfo("Searching parking point line")

            while True:
                if self.fnFindDotLine():
                    break

            rospy.loginfo("Found parking point line")
            rospy.loginfo("TIDOR LU")
            rospy.sleep(5)
            self.current_parking_step = self.StepOfParking.searching_nonreserved_parking_area.value

        elif self.current_parking_step == self.StepOfParking.searching_nonreserved_parking_area.value:
            rospy.loginfo('Searching non reserved parking area')
            
            msg_max_vel = Float64()
            msg_max_vel.data = 0.10
            self.pub_max_vel.publish(msg_max_vel)

            while True:
                if self.is_obstacle_detected == False:
                    self.is_parking_allowed = True
                    rospy.loginfo("First Parking area is available")
                    break
                else:
                    self.is_parking_allowed = False
                    rospy.loginfo("First parking area is full!")
                    break

            if not self.is_parking_allowed:
                rospy.loginfo("SLEEPING BABI")
                rospy.sleep(5)

            rospy.loginfo("Now parking...")
            msg_max_vel = Float64()
            msg_max_vel.data = 0
            self.pub_max_vel.publish(msg_max_vel)

            self.current_parking_step = self.StepOfParking.parking.value

        elif self.current_parking_step == self.StepOfParking.parking.value:

            if self.is_control_parking_triggered == False:
                rospy.loginfo("Now parking ")
                msg_pub_parking_return = UInt8()
                msg_pub_parking_return.data = self.StepOfParking.parking.value
                self.pub_parking_return.publish(msg_pub_parking_return)
                self.is_finish_detect = True
            
            # turn on parking detection
            # self.is_triggered = False

        else:
            rospy.loginfo(f'Unknown parking step: {self.current_parking_step}')

        pass

    def cbParkingOrder(self, order):
        # do nothing for now
        return

        msg_parking_return = UInt8()

        if order.data == self.StepOfParking.searching_parking_point_line.value:
            rospy.loginfo('Searching parking point line')

            msg_pub_max_vel = Float64()
            msg_pub_max_vel.data = 0.06
            self.pub_max_vel.publish(msg_pub_max_vel)

            while True:
                if self.fnFindDotLine():
                    break

                msg_parking_return.data = self.StepOfParking.searching_nonreserved_parking_area.value

        elif order.data == self.StepOfParking.searching_nonreserved_parking_area.value:
            rospy.loginfo('Now searching non reserved parking area')

            self.is_now_parking = True

            msg_pub_max_vel = Float64()
            msg_pub_max_vel.data = 0.10
            self.pub_max_vel.publish(msg_pub_max_vel)

            while True:
                if self.is_obstacle_detected == False:
                    self.is_parking_allowed = True
                    rospy.loginfo('parking is clear')
                    break
                else:
                    self.is_parking_allowed = False
                    rospy.loginfo('Right side is full')

            
            msg_pub_max_vel = Float64()
            msg_pub_max_vel.data = 0.0
            self.pub_max_vel.publish(msg_pub_max_vel)

            msg_parking_return.data = self.StepOfParking.parking.value

        elif order.data == self.StepOfParking.parking.value:

            rospy.loginfo('Now parking')

            msg_parking_start = UInt8()
            msg_parking_start.data = 1
            self.pub_parking_start.publish(msg_parking_start)

        self.pub_parking_return.publish(msg_parking_return)

    def cbScanObstacle(self, scan: LaserScan):
        angle_scan = 60
        scan_start = 270 - angle_scan
        scan_end = 270 + angle_scan
        threshold_distance = 0.5
        is_obstacle_detected = False

        for i in range(scan_start, scan_end):
            if scan.ranges[i] < threshold_distance and scan.ranges[i] > 0.01:
                is_obstacle_detected = True

        self.is_obstacle_detected = is_obstacle_detected
        # rospy.loginfo_throttle(1, f"Obstacle detected: {self.is_obstacle_detected}")

    def fnFindDotLine(self):
        self.cv_bitn_img = cv2.bitwise_not(self.cv_image)
        params = cv2.SimpleBlobDetector_Params()
        # Change thresholds
        params.minThreshold = 0
        params.maxThreshold = 254

        # Filter by Area.
        params.filterByArea = True
        params.minArea = 5000
        params.maxArea = 6000

        # Filter by Circularity
        params.filterByCircularity = True
        params.minCircularity = 0.5

        # Filter by Convexity
        params.filterByConvexity = True
        params.minConvexity = 0.8

        det = cv2.SimpleBlobDetector_create(params)
        keypts = det.detect(self.cv_bitn_img)
        # frame = cv2.drawKeypoints(self.cv_bitn_img, keypts, np.array([]), (0, 0, 255), cv2.DRAW_MATCHES_FLAGS_DRAW_RICH_KEYPOINTS)

        count = 0
        for i in range(len(keypts)):
            x = int(keypts[i].pt[0])
            y = int(keypts[i].pt[1])

            if x > 500:
                count += 1

        if count >= 1:
            return True
        else:
            return False
        
    def main(self):
        rospy.spin()

if __name__ == '__main__':
    rospy.init_node('detect_parking')
    node = DetectParking()
    node.main()